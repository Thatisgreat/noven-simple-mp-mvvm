{"version":3,"sources":["index.js","src/noven.js","src/novenX.js","src/createPage.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const Noven = require('./src/noven.js')\nconst NovenX = require('./src/novenX.js')\nconst createPage = require('./src/createPage.js')\n\nmodule.exports = {\n\tNoven,\n\tNovenX,\n\tcreatePage\n}\n","let uid = 1;\nlet targetStack = []; //保存所有的target\nlet arrayHandler = handleArray();\n\n\n//核心类\nclass Noven {\n\tconstructor($options) {\n\t\tthis.$options = $options;\n\t\tthis._computedWatchers = null;\n\t\tthis.$data = null;\n\n\t\tthis.init($options);\n\n\t\tthis.initProxy();\n\t\tthis.initComputed();\n\t\tthis.initWatch();\n\t\tthis.initMethods();\n\t\tthis.initLifeCycle();\n\t}\n\n\t/**\n\t * [walk 遍历对象，对每个key进行代理]\n\t * @Author   罗文\n\t * @DateTime 2019-04-11\n\t * @param    {[Object]}   obj    [description]\n\t * @param    {Boolean}  isRoot [是否是根节点，如果是，则直接代理在nvm实例上，\n\t * 如果不是，则绑定在对应的对象身上，如 $data.testObj.name，这个name属性就需要代理到nvm.testObj对象身上\n\t * ]\n\t */\n\twalk(obj,isRoot) {\n\t\tif(!obj || typeof obj !== 'object') return;\n\n\t\tObject.entries(obj).forEach(([key,value]) => {\n\t\t\tthis.defineReactive(obj,key,value,isRoot);\n\t\t})\n\t}\n\n\t/**\n\t * [walkArray 遍历数组，对每个key进行代理]\n\t * @Author   罗文\n\t * @DateTime 2019-04-11\n\t * @param    {[Array]}   arr    [要代理的数组]\n\t * ]\n\t */\n\twalkArray(arr) {\n\t\tif(!arr || !Array.isArray(arr)) return;\n\n\t\tarr.__proto__ = arrayHandler;\n\n\t\t//给数组的每一项添加代理，这里用forEach要报错\n\t\tfor(let i = 0 ; i < arr.length ; i ++ ) {\n\t\t\tthis.walk(arr[i]);\n\t\t}\n\t}\n\n\t//进行数据的代理绑定\n\tdefineReactive(obj,key,value,isRoot = false) {\n\t\tlet dep = new Dep(key);\n\n\t\tif(isObject(value) || Array.isArray(value)) defineDep(value,dep);\n\n\t\t//如果值是数组，需要循环添加代理\n\t\tif(Array.isArray(value)) {\n\t\t\tthis.walkArray(value);\n\t\t}\telse {\n\t\t\t//如果值是对象，需要递归代理\n\t\t  this.walk(value, false);\n\t\t}\n\n\t\tlet nvm = this;\n\t\tlet proxyObj = isRoot ? nvm : obj;\n\n\t\tObject.defineProperty(proxyObj,key, {\n\t\t\tenumerable: true,\n      configurable: true,\n      get() {\n      \t// if(key == 'student') debugger\n      \t//每次访问这个属性，如某一个computed中使用了这个属性，\n      \t//此时dep.depend()中的Dep.target就是这个computed对应的watcher，\n      \t//需要向此watcher的deps数组中添加当前dep，同时在当前dep的subs数组中添加该watcher\n      \t//建立 dep<->watcher的依赖关系\n      \tdep.depend();\n        return value\n      },\n      set(newValue) {\n      \tif( value === newValue ) return;\n\n      \tif(isObject(newValue) || Array.isArray(newValue)) defineDep(newValue,dep);\n      \t//如果值是数组，需要循环添加代理\n\t\t\t\tif(Array.isArray(newValue)) {\n\t\t\t\t\tnvm.walkArray(newValue);\n\t\t\t\t}\telse {\n\t\t\t\t\tnvm.walk(newValue, false);\n\t\t\t\t}\n        \n        value = newValue\n        dep.notify();\n      }\n\t\t})\n\t}\n\n\t/**\n\t * [defineComputed 进行computed的代理绑定]\n\t * @Author   罗文\n\t * @DateTime 2019-04-11\n\t * @param    {[String]}   key  [computed的键]\n\t * @param    {[Function]}   func [计算computed值的表达式]\n\t */\n\tdefineComputed(key,func) {\n\t\tlet nvm = this;\n\t\tObject.defineProperty(nvm,key, {\n\t\t\tenumerable: true,\n      configurable: true,\n      get() {\n        return func.call(nvm);\n      },\n      set(newValue) {\n      \tconsole.warn('不能设置computed的值')\n      }\n\t\t})\n\t}\n}\n\n//可以进行一些额外的初始化工作，在所有任务开始之前\n//如添加store，添加mixins等\nNoven.prototype.init = function(options) {}\n\n\n//初始化data数据代理\nNoven.prototype.initProxy = function() {\n\tif(!this.$options.data) return;\n\n\tlet { data } = this.$options;\n\tthis.$data = data;\n\n\tthis.walk(this.$data, true);\n}\n\n//生命周期\nNoven.prototype.initLifeCycle = function() {\n\tlet { \n\t\tcreated\n\t} = this.$options;\n\n\t//执行created生命周期\n\tif(created) created.call(this);\n}\n//计算属性\nNoven.prototype.initComputed = function() {\n\tif(!this.$options.computed) return;\n\t//就是用来保存computed相关watcher的\n\tlet watchers = this._computedWatchers = Object.create(null);\n\n\tObject.entries(this.$options.computed).forEach(([key,value]) =>{\n\t\t//如果computed是一个函数，则直接把这个函数做为这个computed得到的key的getter\n\t\t//如果是对象，则取这个对象的get\n\t\tlet getter = typeof value === 'function' ? value : value.get;\n\t\tgetter = getter || noop;\n\n\t\t//每一个computed都是一个watcher\n\t\twatchers[key] = new Watcher(this,getter,noop);\n\n\t\t//将每一个computed的key，代理到nvm身上，可以通过this.xxx来访问这个computed\n\t\tthis.defineComputed(key,getter);\n\t})\n}\n//watch对象\nNoven.prototype.initWatch = function() {\n\tif(!this.$options.watch) return;\n\tObject.entries(this.$options.watch).forEach(([key,value]) =>{\n\t\t//每一个watch都是一个watcher\n\t\tnew Watcher(this,key,value);\n\t})\n}\n\n//methods对象\nNoven.prototype.initMethods = function() {\n\tif(!this.$options.methods) return;\n\n\tObject.entries(this.$options.methods).forEach(([key,value]) =>{\n\t\tthis[key] = value.bind(this,...arguments);\n\t})\n\n}\n\n\n//自定义对一个对象进行监听\nNoven.prototype.$watch = function(keyOrObjFunc,cb,option) {\n\tif(typeof keyOrObjFunc === 'string' || typeof keyOrObjFunc === 'function') {\n\t\tnew Watcher(this,keyOrObjFunc,cb,option);\n\t}\n}\n\n\n\n\n\n\n/*  --------- Dep 相关 ---------  */\n/*\n  Dep的作用\n  1、data中每一个key，都会有一个dep实例，这个实例在defineReactive生命，并且被闭包一直缓存着\n    let dep = new Dep();\n    Object.defineProperty中的get和set,每次执行，都是用的缓存的dep实例，如\n    dep.depend();\n    dep.notify();\n    Dep.target.addDep(this) 中的this;\n  2、\n */\nfunction Dep(key) {\n\tthis.name = key;\n\tthis.id = uid ++;\n\tthis.subs = [];\n}\n\nDep.prototype.addSubs = function(watcher) {\n\tlet { id } = watcher;\n\t//相同watcher只添加一次\n\tif(!this.subs.find(sub => sub.id === id)) this.subs.push(watcher);\n}\n\nDep.prototype.removeSub = function(watcher) {\n\tlet index = this.subs.findIndex(sub => sub.id === watcher.id);\n\tif(index > -1) this.subs.splice(index,1);\n}\n\n// 将dep添加到对应的watcher实例中，建立watcher -> dep直接的依赖关系\n// Dep.target 就是 new Watcher的实例\n// 一个watcher对应多个dep，如果data有多个key，则最后watcher的deps数组就含有所有key的deps\nDep.prototype.depend = function() {\n\tif( Dep.target ) {\n\t\tDep.target.addDep(this);\n\t}\n}\n\n//给属性设置新值会触发setter，同时会触发闭包的dep的更新\n//循环subs数组，触发每个watcher的更新\nDep.prototype.notify = function() {\n\tfor (var i = 0, l = this.subs.length; i < l; i++) {\n    this.subs[i].update();\n  }\n}\n\n\n\n/* ----------- Watcher 相关 ------- */\n\n/**\n * [Watcher 构造函数，建立与属性的依赖]\n * @Author   Noven\n * @DateTime 2019-04-11\n * @param    {[Object]}   nvm        [框架的实例化对象]\n * @param    {[type]}   funcOrExp [函数或者表达式]\n * @param    {Function} cb        [属性变化的回调函数]\n */\nfunction Watcher(nvm,funcOrExp,cb,options) {\n\tthis.id = uid ++;\n\n\tthis.newDeps = []; //保存本次事件循环中所有的dep\n\tthis.newDepIds = [];  //保存本次事件循环中所有的depId，不会重复\n\tthis.deps = []; //保存上次事件循环所有的dep\n\tthis.depIds = [];  //保存上次事件循环所有的depId，不会重复\n\n\tthis.cb = cb || noop; //依赖变化后的回调\n\tthis.nvm = nvm;\n\tthis.deep = options && options.deep;\n\n\t//将传入的函数或表达式做为watcher实例的getter\n\t//如果funcOrExp不是函数，则可能是watch对象，此时的funcOrExp就是每个watch对应的key\n\tthis.getter = typeof funcOrExp === 'function' ? funcOrExp : (()=> {\n\t\tif(typeof funcOrExp !== 'string' || !funcOrExp.includes('.')) return nvm[funcOrExp]\n\n\t\t//可以接收 hello => this.hello      testObj.hello => this.testObj.hello\t\n\t\tlet propSplit = funcOrExp.split('.');\n\t\tlet value = nvm;\n\t\tpropSplit.forEach(key => value = value[key]);\n\t\t\n\t\treturn value\n\t});\n\n\tthis.value = this.get()\n}\n\n//添加一个dep\n//每次获取属性如，this.name，都会触发getter，也都会触发addDep操作，所以需要不会重复添加同一个dep\nWatcher.prototype.addDep = function(dep) {\n\tlet depId = dep.id;\n\n\tif( !this.newDepIds.includes(depId) ) {\n\t\t//将dep保存到watcher的deps依赖数组中\n\t\tthis.newDeps.push(dep);\n\t\tthis.newDepIds.push(depId);\n\t\t//同时，在dep的subs数组中，也新增watcher依赖\n\t\tdep.addSubs(this);\n\t}\n}\n\n\n//实例化watcher的时候，将这个watcher绑定到Dep类的静态属性target身上\n//其后实例化出来的所有dep，都有这个target，且是同一个watcher\nWatcher.prototype.pushTarget = function() {\n\ttargetStack.push(this)\n\tDep.target = this;\n}\n\n//多数情况下，Dep.target应该为null\n//只有在watcher取值的时候（new的时候和update的时候），才有 Dep.target = watcher\n//所以用完就要清掉\nWatcher.prototype.popTarget = function() {\n\ttargetStack.pop()\n\tDep.target = targetStack[targetStack.length - 1];\n}\n\n//\nWatcher.prototype.cleanDeps = function() {\n\tvar i = this.deps.length;\n  while (i--) {\n    var dep = this.deps[i];\n    if (!this.newDepIds.includes(dep.id)) {\n      dep.removeSub(this);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds = [];\n\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps = [];\n}\n\n//实例化watcher的时候，需要计算当前watcher对应的value，并且将当前watcher\n//保存到Dep.target身上\nWatcher.prototype.get = function() {\n\tthis.pushTarget();\n\tlet value;\n\ttry {\n\t  value = this.getter.call(this.nvm);\n\t}catch(e) {\n\t  console.error('获取初始值失败！')\n\t}finally {\n\t  // if(this.deep) deepTransfer(value);\n\t  deepTransfer(value);\n\t}\n\n\tthis.popTarget();\n\tthis.cleanDeps()\n\treturn value;\n}\n\n//每次依赖属性的改变，都会触发dep下所有的watcher更新\nWatcher.prototype.update = function() {\n\t//这里暂时采用同步更新\n\tthis.run();\n}\n\n//每次update都会有同步更新和异步更新\n//异步更新会推送到异步队列，采用microtasks和macrotasks的方式更新，不过最后更新时都是调用的run\n//同步更新，直接调用run\nWatcher.prototype.run = function() {\n\t//每次执行run的时候，先判断新值和旧值，不同才更新\n\tconst value = this.get();\n  if (value !== this.value || isObject(value) || Array.isArray(value) || this.deep) {\n    const oldValue = this.value;\n    this.value = value;\n    //执行更新后的回调，一般用于watch的调用\n    this.cb.call(this.nvm, value, oldValue);\n    //后面就是调用diff算法，更新界面了\n  }\n}\n\n\n\n\n//一个占位的函数，主要是用来做兼容的\n//如 cb = cb || noop\nfunction noop (a, b, c) {}\nfunction isObject(val) {\n\treturn Object.prototype.toString.call(val).includes('Object');\n}\n\n\n//拦截数组的某些操作方法\n//通过调用这些方法，触发数组的dep的notify -> watcher的update -> 界面的更新\nfunction handleArray() {\n\tlet arrayProto = Object.create(Array.prototype);\n\tlet arrayMethods = [\n\t  'push',\n\t  'pop',\n\t  'shift',\n\t  'unshift',\n\t  'splice',\n\t  'sort',\n\t  'reverse'\n\t];\n\tarrayMethods.forEach(method => {\n\t  Object.defineProperty(arrayProto,method,{\n\t    enumerable: false,\n\t    writable: true,\n\t    configurable: true,\n\t    value: function(...arg) {\n\t      //Array对应的这个方法，先取出来\n\t      let original = Array.prototype[method];\n\n\t      //这里就是重写方法的核心代码\n\t      //在初始化的时候，会给数组添加一个dep对象，保存与watcher的关系，每次调用\n\t      //这些方法的时候，就会触发watcher更新\n\t      if(this.__dep__) this.__dep__.notify()\n\n\t      //执行原数组的对应方法，返回值\n\t      return original.apply(this,arg);\n\t    }\n\t  })\n\t})\n\n\treturn arrayProto;\n}\n\n\n//递归触发内部的每一个键，目的是为了调用每一个key的get，触发其dep.depend()\nfunction deepTransfer(obj) {\n\tlet set = new Set();\n\n\tfunction _deepTransfer(val) {\n\t\tlet isObj = isObject(val);\n\t\tif(!Array.isArray(val) && !isObj) return;\n\n\t\t//本次递归中，同一个key的dep，只会保存一次\n\t\tlet dep = val.__dep__;\n\t\tif(dep) {\n\t\t\tif(set.has(dep.id)) return;\n\t\t  set.add(dep.id);\n\t\t}\n\n\t\tif(Array.isArray(val)) {\n\t\t\tval.forEach(item => {\n\t\t\t\t_deepTransfer(item)\n\t\t\t});\n\t\t}\n\n\t\tif(isObj) {\n\t\t\tObject.entries(val).forEach(([key,value]) => {\n\t\t\t\t_deepTransfer(value)\n\t\t\t});\n\t\t}\n\t}\n\n\t_deepTransfer(obj);\n\n}\n\nfunction defineDep(obj,value) {\n\tObject.defineProperty(obj,'__dep__',{\n    enumerable:false,\n    value\n  })\n}\n\n\nmodule.exports = Noven;\n\n\n\n","const Noven = require('./noven.js')\n\nmodule.exports = class Store {\n  constructor(options) {\n  \t//挂载到Noven身上\n  \tif(!Noven) return;\n  \tthis.$options = options;\n  \t//保存所有action\n  \tthis._actionsSubscribers = {};\n  \t//保存所有mutation\n  \tthis._mutationsSubscribers = {};\n  \t//不允许直接修改vuex中的值\n  \tthis.$committing = false;\n\n\n  \tlet _this = this;\n  \tlet init = Noven.prototype.init;\n  \tNoven.prototype.init = function (nvmOptions) {\n  \t\tif(Object.keys(nvmOptions).includes('store')) {\n  \t\t\tthis.$store = _this;\n  \t\t}\n\n  \t\tinit.call(this);\n  \t}\n\n  \t//执行store的初始化工作\n  \tthis.initState();\n\n  \t//初始化所有actions 和 mutations\n  \tthis.initMethods();\n\n\n  \t//不允许直接修改state的值\n  \tlet nvm = this._nvm;\n\n  \tthis._nvm.$watch(function() {\n  \t\treturn getLastData(nvm,options)\n  \t},(nv)=> {\n  \t\tif(!this.$committing) {\n  \t\t\tconsole.warn('只能通过commit修改state的值');\n  \t\t}\n  \t},{\n  \t\tdeep: true\n  \t})\n  }\n\n\n\t//Store的state实际上就是一个Vue实例，也就是Noven实例\n\t//这个实例只具备data和computed（实际上对应vuex中的getters）\n  initState() {\n\t\tlet { state: data = {}, computed = {} } = this.$options;\n\n\t\tthis._nvm = new Noven({\n\t\t\tdata,\n\t\t\tcomputed\n\t\t})\n\n\t\t//代理一下，将 $options中配置的所有的state和computed都代理到this.$store\n\t\t//可以通过 this.$store.xxx 来访问 this.$store._nvm \n\t\tfunction defineReactive(obj,key) {\n\t\t\tObject.defineProperty(obj,key,{\n\t\t\t\tenumerable: true,\n        configurable: true,\n\t\t\t\tget() {\n\t\t\t\t\treturn this._nvm[key];\n\t\t\t\t},\n\t\t\t\tset(nv) {\n\t\t\t\t\tthis._nvm[key] = nv;\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tObject.keys(data).forEach(key => defineReactive(this,key));\n\t\tObject.keys(computed).forEach(key => defineReactive(this,key));\n\t}\n\n\n\t//初始化所有actions 和 mutations\n  initMethods() {\n\t\tlet { actions = {}, mutations = {} } = this.$options;\n\t\tlet _this = this;\n\n\t\t//工厂模式\n\t\tfunction factory(server,name) {\n\t\t\tif(!Object.prototype.toString.call(server).includes('Object')) return;\n\t\t\tObject.entries(server).forEach(([key,value]) => {\n\t\t\t\tif(name !== '_actions') \n\t\t\t\t\t//mutation\n\t\t\t\t\t_this[`${name}Subscribers`][key] = function() {\n\t\t\t\t\t\treturn value.call(_this,...arguments);\n\t\t\t\t\t}\n\t\t\t\telse \n\t\t\t\t\t//action\n\t\t\t\t\t_this[`${name}Subscribers`][key] = function() {\n\t\t\t\t\t\treturn Promise.resolve().then(() => value.call(_this,...arguments))\n\t\t\t\t\t};\n\t\t\t})\n\t\t}\n\n\t\tfactory(actions,'_actions');\n\t\tfactory(mutations,'_mutations');\n\t}\n\n\n\t//触发actions\n\tdispatch(actionName, params) {\n\t\tif(!actionName) {\n\t\t\tconsole.warn('dispatch要触发的action不能为空！');\n\t\t\treturn;\n\t\t}\n\n\t\tlet action = this._actionsSubscribers[actionName];\n\n\t\tif(!action) {\n\t\t\tconsole.warn(`action[${actionName}]不存在！`);\n\t\t\treturn;\n\t\t}\n\n\t\treturn action(params);\n\t}\n\n\t//触发mutations\n\tcommit(mutationName, params) {\n\t\tif(!mutationName) {\n\t\t\tconsole.warn('commit要触发的mutation不能为空！');\n\t\t\treturn;\n\t\t}\n\n\t\tlet mutation = this._mutationsSubscribers[mutationName];\n\n\t\tif(!mutation) {\n\t\t\tconsole.warn(`mutation[${mutationName}]不存在！`);\n\t\t\treturn;\n\t\t}\t\n\n\t\t//只有mutation才允许改变state\n\t\tthis.$committing = true;\n\t\tmutation(params);\n\t\tthis.$committing = false;\n\t}\n}\n\n\nfunction getLastData(nvm,options) {\n  let keys = [];\n  let obj = {};\n\n  let { state, computed } = options\n  if(state) keys.push(...Object.keys(state))\n  if(computed) keys.push(...Object.keys(computed))\n\n  keys.forEach(key => obj[key] = nvm[key])  \n  return obj;\n}","const Noven = require('./noven.js')\n\nfunction createPage(options) {\n  let params = {};\n  params.$options = options;\n\n  //在页面渲染之前，初始化一些配置信息，如登录拦截，methods拦截等\n  initConfig(options);\n\n  params.onLoad = function(query) {\n    //初始化vue\n    initNvm(this,options);\n    //执行生命周期的onLoad\n    if(options.onLoad) options.onLoad.call(this,query);\n  }\n\n  params.onReady = function() {\n    if(options.onReady) options.onReady.call(this);\n  }\n\n  Page(params)\n}\n\n\n\nfunction initNvm(wxPage,options) {\n  let nvm = new Noven(options)\n  nvm.$wxPage = wxPage;\n  nvm.$options = options\n\n  //初始化首屏数据\n  initState(nvm)\n  //初始化所有事件\n  initMethods(nvm);\n\n  nvm.$watch(()=>{\n    return getLastData(nvm,options)\n  },(nv,ov)=> {\n    wxPage.setData(nv)\n  })\n}\n\n\nfunction initState(nvm) {\n  let { $wxPage, $options } = nvm;\n  $wxPage.setData(getLastData(nvm,$options))\n}\n\nfunction initMethods(nvm) {\n  let { methods } = nvm.$options;\n\n  if(!methods) return;\n  Object.entries(methods).forEach(([key,value]) => {\n    Object.defineProperty(nvm.$wxPage,key, {\n      enumerable: true,\n      configurable: false,\n      get() {\n        return nvm[key]\n      }\n    })\n  })\n}\n\nfunction initConfig(options) {\n  let { config, methods = {} } = options;\n\n  if(!config) return;\n\n  let { vModel } = config;\n\n  //初始化input框的双向数据绑定，实质就是自动添加对应的bindinput\n  //如v-model=\"hello\"，则自动生成一个method: set_hello\n  //只接受一层vmodel， this.hello.world是不允许的\n  if(vModel) {\n    vModel.forEach(model => {\n      //如果methods里有同名方法，以methods为准\n      if(methods[`set_${model}`]) return;\n\n      methods[`set_${model}`] = function(e) {\n        this[model] = e.detail.value;\n      }\n    })\n  }\n}\n\nfunction getLastData(nvm,options) {\n  let keys = [];\n  let obj = {};\n\n  let { data, computed } = options\n  if(data) keys.push(...Object.keys(data))\n  if(computed) keys.push(...Object.keys(computed))\n\n  keys.forEach(key => obj[key] = nvm[key])  \n  return obj;\n}\n\nfunction diff(nv,ov) {\n  console.log(nv,ov);\n  //先移除每个节点的__dep\n}\n\n\nmodule.exports = createPage"]}